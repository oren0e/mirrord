window.SIDEBAR_ITEMS = {"fn":[["close_detour","Attempts to close on a managed `Socket`, if there is no socket with `fd`, then this means we either let the `fd` bypass and call [`libc::close`] directly, or it might be a managed file `fd`, so it tries to do the same for files."],["close_layer_fd","Shared code for closing `fd` in our data structures."],["close_nocancel_detour","No need to guard because we call another detour which will do the guard for us."],["enable_hooks","Prepares the [`HookManager`] and [`replace!`]s [`libc`] calls with our hooks, according to what the user configured."],["is_nix_or_devbox","Check if NixOS or Devbox by discrimnating env vars."],["layer_pre_initialization","Loads mirrord configuration and applies [`nix_devbox_patch`] patches."],["layer_start","Occurs after [`layer_pre_initialization`] has succeeded."],["mirrord_layer_entry_point","The one true start of mirrord-layer."],["nix_devbox_patch","Check if we’re running in NixOS or Devbox."],["port_debug_patch","Prevent mirrord from connecting to ports used by the intelliJ debugger"],["start_layer_thread","Initializes mirrord-layer’s [`thread_loop`] in a separate [`tokio::task`]."],["thread_loop","Main loop of mirrord-layer."],["uv_fs_close","Hook"]],"macro":[["graceful_exit","Kills the process and prints a helpful error message to the user."],["replace","Replaces the `$func` [`libc`] function, with the equivalent hook `$detour_function`, by calling `HookManager::hook_export_or_any`."]],"mod":[["common","Shared place for a few types and functions that are used everywhere by the layer."],["connection","Module for the mirrord-layer/mirrord-agent connection mechanism."],["detour","The layer uses features from this module to check if it should bypass one of its hooks, and call the original [`libc`] function."],["dns","Holds the [`GetAddrInfo`] `HookMessage` used to perform DNS lookup in a remote context."],["error",""],["file",""],["go_hooks",""],["hooks",""],["load",""],["macros","Macros used by mirrord-layer (mostly for hooking [`libc`] functions)."],["outgoing",""],["socket","We implement each hook function in a safe function as much as possible, having the unsafe do the absolute minimum"],["tcp",""],["tcp_mirror",""],["tcp_steal",""],["tracing_util",""]],"static":[["ENABLED_TCP_OUTGOING","Tells us if the user enabled the Tcp outgoing feature in [`NetworkConfig`]."],["ENABLED_UDP_OUTGOING","Tells us if the user enabled the Udp outgoing feature in [`NetworkConfig`]."],["FILE_MODE","Holds the file operations configuration, as specified by [`FsConfig`]."],["FN_CLOSE",""],["FN_CLOSE_NOCANCEL",""],["FN_UV_FS_CLOSE",""],["HOOK_SENDER","[`Sender`] for the [`HookMessage`]s that are handled internally, and converted (when applicable) to [`ClientMessage`]s."],["RUNTIME","Main tokio [`Runtime`] for mirrord-layer async tasks."]],"struct":[["Layer","Acts as an API to the various features of mirrord-layer, holding the actual feature handler types."]],"type":[["FnClose",""],["FnClose_nocancel",""],["FnUv_fs_close",""]]};